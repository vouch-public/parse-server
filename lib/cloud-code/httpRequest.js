"use strict";

var _HTTPResponse = _interopRequireDefault(require("./HTTPResponse"));
var _querystring = _interopRequireDefault(require("querystring"));
var _logger = _interopRequireDefault(require("../logger"));
var _followRedirects = require("follow-redirects");
var _url = require("url");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const clients = {
  'http:': _followRedirects.http,
  'https:': _followRedirects.https
};
function makeCallback(resolve, reject) {
  return function (response) {
    const chunks = [];
    response.on('data', chunk => {
      chunks.push(chunk);
    });
    response.on('end', () => {
      const body = Buffer.concat(chunks);
      const httpResponse = new _HTTPResponse.default(response, body);

      // Consider <200 && >= 400 as errors
      if (httpResponse.status < 200 || httpResponse.status >= 400) {
        return reject(httpResponse);
      } else {
        return resolve(httpResponse);
      }
    });
    response.on('error', reject);
  };
}
const encodeBody = function ({
  body,
  headers = {}
}) {
  if (typeof body !== 'object') {
    return {
      body,
      headers
    };
  }
  var contentTypeKeys = Object.keys(headers).filter(key => {
    return key.match(/content-type/i) != null;
  });
  if (contentTypeKeys.length == 0) {
    // no content type
    //  As per https://parse.com/docs/cloudcode/guide#cloud-code-advanced-sending-a-post-request the default encoding is supposedly x-www-form-urlencoded

    body = _querystring.default.stringify(body);
    headers['Content-Type'] = 'application/x-www-form-urlencoded';
  } else {
    /* istanbul ignore next */
    if (contentTypeKeys.length > 1) {
      _logger.default.error('Parse.Cloud.httpRequest', 'multiple content-type headers are set.');
    }
    // There maybe many, we'll just take the 1st one
    var contentType = contentTypeKeys[0];
    if (headers[contentType].match(/application\/json/i)) {
      body = JSON.stringify(body);
    } else if (headers[contentType].match(/application\/x-www-form-urlencoded/i)) {
      body = _querystring.default.stringify(body);
    }
  }
  return {
    body,
    headers
  };
};

/**
 * Makes an HTTP Request.
 *
 * **Available in Cloud Code only.**
 *
 * By default, Parse.Cloud.httpRequest does not follow redirects caused by HTTP 3xx response codes. You can use the followRedirects option in the {@link Parse.Cloud.HTTPOptions} object to change this behavior.
 *
 * Sample request:
 * ```
 * Parse.Cloud.httpRequest({
 *   url: 'http://www.parse.com/'
 * }).then(function(httpResponse) {
 *   // success
 *   console.log(httpResponse.text);
 * },function(httpResponse) {
 *   // error
 *   console.error('Request failed with response code ' + httpResponse.status);
 * });
 * ```
 *
 * @method httpRequest
 * @name Parse.Cloud.httpRequest
 * @param {Parse.Cloud.HTTPOptions} options The Parse.Cloud.HTTPOptions object that makes the request.
 * @return {Promise<Parse.Cloud.HTTPResponse>} A promise that will be resolved with a {@link Parse.Cloud.HTTPResponse} object when the request completes.
 */
module.exports = function httpRequest(options) {
  let url;
  try {
    url = (0, _url.parse)(options.url);
  } catch (e) {
    return Promise.reject(e);
  }
  options = Object.assign(options, encodeBody(options));
  // support params options
  if (typeof options.params === 'object') {
    options.qs = options.params;
  } else if (typeof options.params === 'string') {
    options.qs = _querystring.default.parse(options.params);
  }
  const client = clients[url.protocol];
  if (!client) {
    return Promise.reject(`Unsupported protocol ${url.protocol}`);
  }
  const requestOptions = {
    method: options.method,
    port: Number(url.port),
    path: url.pathname,
    hostname: url.hostname,
    headers: options.headers,
    encoding: null,
    followRedirects: options.followRedirects === true
  };
  if (requestOptions.headers) {
    Object.keys(requestOptions.headers).forEach(key => {
      if (typeof requestOptions.headers[key] === 'undefined') {
        delete requestOptions.headers[key];
      }
    });
  }
  if (url.search) {
    options.qs = Object.assign({}, options.qs, _querystring.default.parse(url.query));
  }
  if (url.auth) {
    requestOptions.auth = url.auth;
  }
  if (options.qs) {
    requestOptions.path += `?${_querystring.default.stringify(options.qs)}`;
  }
  if (options.agent) {
    requestOptions.agent = options.agent;
  }
  return new Promise((resolve, reject) => {
    const req = client.request(requestOptions, makeCallback(resolve, reject, options));
    if (options.body) {
      req.write(options.body);
    }
    req.on('error', error => {
      reject(error);
    });
    req.end();
  });
};

/**
 * @typedef Parse.Cloud.HTTPOptions
 * @property {String|Object} body The body of the request. If it is a JSON object, then the Content-Type set in the headers must be application/x-www-form-urlencoded or application/json. You can also set this to a {@link Buffer} object to send raw bytes. If you use a Buffer, you should also set the Content-Type header explicitly to describe what these bytes represent.
 * @property {function} error The function that is called when the request fails. It will be passed a Parse.Cloud.HTTPResponse object.
 * @property {Boolean} followRedirects Whether to follow redirects caused by HTTP 3xx responses. Defaults to false.
 * @property {Object} headers The headers for the request.
 * @property {String} method The method of the request. GET, POST, PUT, DELETE, HEAD, and OPTIONS are supported. Will default to GET if not specified.
 * @property {String|Object} params The query portion of the url. You can pass a JSON object of key value pairs like params: {q : 'Sean Plott'} or a raw string like params:q=Sean Plott.
 * @property {function} success The function that is called when the request successfully completes. It will be passed a Parse.Cloud.HTTPResponse object.
 * @property {string} url The url to send the request to.
 */

module.exports.encodeBody = encodeBody;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjbGllbnRzIiwiaHR0cCIsImh0dHBzIiwibWFrZUNhbGxiYWNrIiwicmVzb2x2ZSIsInJlamVjdCIsInJlc3BvbnNlIiwiY2h1bmtzIiwib24iLCJjaHVuayIsInB1c2giLCJib2R5IiwiQnVmZmVyIiwiY29uY2F0IiwiaHR0cFJlc3BvbnNlIiwiSFRUUFJlc3BvbnNlIiwic3RhdHVzIiwiZW5jb2RlQm9keSIsImhlYWRlcnMiLCJjb250ZW50VHlwZUtleXMiLCJPYmplY3QiLCJrZXlzIiwiZmlsdGVyIiwia2V5IiwibWF0Y2giLCJsZW5ndGgiLCJxdWVyeXN0cmluZyIsInN0cmluZ2lmeSIsImxvZyIsImVycm9yIiwiY29udGVudFR5cGUiLCJKU09OIiwibW9kdWxlIiwiZXhwb3J0cyIsImh0dHBSZXF1ZXN0Iiwib3B0aW9ucyIsInVybCIsInBhcnNlIiwiZSIsIlByb21pc2UiLCJhc3NpZ24iLCJwYXJhbXMiLCJxcyIsImNsaWVudCIsInByb3RvY29sIiwicmVxdWVzdE9wdGlvbnMiLCJtZXRob2QiLCJwb3J0IiwiTnVtYmVyIiwicGF0aCIsInBhdGhuYW1lIiwiaG9zdG5hbWUiLCJlbmNvZGluZyIsImZvbGxvd1JlZGlyZWN0cyIsImZvckVhY2giLCJzZWFyY2giLCJxdWVyeSIsImF1dGgiLCJhZ2VudCIsInJlcSIsInJlcXVlc3QiLCJ3cml0ZSIsImVuZCJdLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jbG91ZC1jb2RlL2h0dHBSZXF1ZXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBIVFRQUmVzcG9uc2UgZnJvbSAnLi9IVFRQUmVzcG9uc2UnO1xuaW1wb3J0IHF1ZXJ5c3RyaW5nIGZyb20gJ3F1ZXJ5c3RyaW5nJztcbmltcG9ydCBsb2cgZnJvbSAnLi4vbG9nZ2VyJztcbmltcG9ydCB7IGh0dHAsIGh0dHBzIH0gZnJvbSAnZm9sbG93LXJlZGlyZWN0cyc7XG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gJ3VybCc7XG5cbmNvbnN0IGNsaWVudHMgPSB7XG4gICdodHRwOic6IGh0dHAsXG4gICdodHRwczonOiBodHRwcyxcbn07XG5cbmZ1bmN0aW9uIG1ha2VDYWxsYmFjayhyZXNvbHZlLCByZWplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIHJlc3BvbnNlLm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgIH0pO1xuICAgIHJlc3BvbnNlLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gQnVmZmVyLmNvbmNhdChjaHVua3MpO1xuICAgICAgY29uc3QgaHR0cFJlc3BvbnNlID0gbmV3IEhUVFBSZXNwb25zZShyZXNwb25zZSwgYm9keSk7XG5cbiAgICAgIC8vIENvbnNpZGVyIDwyMDAgJiYgPj0gNDAwIGFzIGVycm9yc1xuICAgICAgaWYgKGh0dHBSZXNwb25zZS5zdGF0dXMgPCAyMDAgfHwgaHR0cFJlc3BvbnNlLnN0YXR1cyA+PSA0MDApIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChodHRwUmVzcG9uc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoaHR0cFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXNwb25zZS5vbignZXJyb3InLCByZWplY3QpO1xuICB9O1xufVxuXG5jb25zdCBlbmNvZGVCb2R5ID0gZnVuY3Rpb24gKHsgYm9keSwgaGVhZGVycyA9IHt9IH0pIHtcbiAgaWYgKHR5cGVvZiBib2R5ICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB7IGJvZHksIGhlYWRlcnMgfTtcbiAgfVxuICB2YXIgY29udGVudFR5cGVLZXlzID0gT2JqZWN0LmtleXMoaGVhZGVycykuZmlsdGVyKGtleSA9PiB7XG4gICAgcmV0dXJuIGtleS5tYXRjaCgvY29udGVudC10eXBlL2kpICE9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChjb250ZW50VHlwZUtleXMubGVuZ3RoID09IDApIHtcbiAgICAvLyBubyBjb250ZW50IHR5cGVcbiAgICAvLyAgQXMgcGVyIGh0dHBzOi8vcGFyc2UuY29tL2RvY3MvY2xvdWRjb2RlL2d1aWRlI2Nsb3VkLWNvZGUtYWR2YW5jZWQtc2VuZGluZy1hLXBvc3QtcmVxdWVzdCB0aGUgZGVmYXVsdCBlbmNvZGluZyBpcyBzdXBwb3NlZGx5IHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuXG4gICAgYm9keSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeShib2R5KTtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKGNvbnRlbnRUeXBlS2V5cy5sZW5ndGggPiAxKSB7XG4gICAgICBsb2cuZXJyb3IoJ1BhcnNlLkNsb3VkLmh0dHBSZXF1ZXN0JywgJ211bHRpcGxlIGNvbnRlbnQtdHlwZSBoZWFkZXJzIGFyZSBzZXQuJyk7XG4gICAgfVxuICAgIC8vIFRoZXJlIG1heWJlIG1hbnksIHdlJ2xsIGp1c3QgdGFrZSB0aGUgMXN0IG9uZVxuICAgIHZhciBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlS2V5c1swXTtcbiAgICBpZiAoaGVhZGVyc1tjb250ZW50VHlwZV0ubWF0Y2goL2FwcGxpY2F0aW9uXFwvanNvbi9pKSkge1xuICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgIH0gZWxzZSBpZiAoaGVhZGVyc1tjb250ZW50VHlwZV0ubWF0Y2goL2FwcGxpY2F0aW9uXFwveC13d3ctZm9ybS11cmxlbmNvZGVkL2kpKSB7XG4gICAgICBib2R5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KGJvZHkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBib2R5LCBoZWFkZXJzIH07XG59O1xuXG4vKipcbiAqIE1ha2VzIGFuIEhUVFAgUmVxdWVzdC5cbiAqXG4gKiAqKkF2YWlsYWJsZSBpbiBDbG91ZCBDb2RlIG9ubHkuKipcbiAqXG4gKiBCeSBkZWZhdWx0LCBQYXJzZS5DbG91ZC5odHRwUmVxdWVzdCBkb2VzIG5vdCBmb2xsb3cgcmVkaXJlY3RzIGNhdXNlZCBieSBIVFRQIDN4eCByZXNwb25zZSBjb2Rlcy4gWW91IGNhbiB1c2UgdGhlIGZvbGxvd1JlZGlyZWN0cyBvcHRpb24gaW4gdGhlIHtAbGluayBQYXJzZS5DbG91ZC5IVFRQT3B0aW9uc30gb2JqZWN0IHRvIGNoYW5nZSB0aGlzIGJlaGF2aW9yLlxuICpcbiAqIFNhbXBsZSByZXF1ZXN0OlxuICogYGBgXG4gKiBQYXJzZS5DbG91ZC5odHRwUmVxdWVzdCh7XG4gKiAgIHVybDogJ2h0dHA6Ly93d3cucGFyc2UuY29tLydcbiAqIH0pLnRoZW4oZnVuY3Rpb24oaHR0cFJlc3BvbnNlKSB7XG4gKiAgIC8vIHN1Y2Nlc3NcbiAqICAgY29uc29sZS5sb2coaHR0cFJlc3BvbnNlLnRleHQpO1xuICogfSxmdW5jdGlvbihodHRwUmVzcG9uc2UpIHtcbiAqICAgLy8gZXJyb3JcbiAqICAgY29uc29sZS5lcnJvcignUmVxdWVzdCBmYWlsZWQgd2l0aCByZXNwb25zZSBjb2RlICcgKyBodHRwUmVzcG9uc2Uuc3RhdHVzKTtcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQG1ldGhvZCBodHRwUmVxdWVzdFxuICogQG5hbWUgUGFyc2UuQ2xvdWQuaHR0cFJlcXVlc3RcbiAqIEBwYXJhbSB7UGFyc2UuQ2xvdWQuSFRUUE9wdGlvbnN9IG9wdGlvbnMgVGhlIFBhcnNlLkNsb3VkLkhUVFBPcHRpb25zIG9iamVjdCB0aGF0IG1ha2VzIHRoZSByZXF1ZXN0LlxuICogQHJldHVybiB7UHJvbWlzZTxQYXJzZS5DbG91ZC5IVFRQUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggYSB7QGxpbmsgUGFyc2UuQ2xvdWQuSFRUUFJlc3BvbnNlfSBvYmplY3Qgd2hlbiB0aGUgcmVxdWVzdCBjb21wbGV0ZXMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHR0cFJlcXVlc3Qob3B0aW9ucykge1xuICBsZXQgdXJsO1xuICB0cnkge1xuICAgIHVybCA9IHBhcnNlKG9wdGlvbnMudXJsKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgfVxuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihvcHRpb25zLCBlbmNvZGVCb2R5KG9wdGlvbnMpKTtcbiAgLy8gc3VwcG9ydCBwYXJhbXMgb3B0aW9uc1xuICBpZiAodHlwZW9mIG9wdGlvbnMucGFyYW1zID09PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMucXMgPSBvcHRpb25zLnBhcmFtcztcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5wYXJhbXMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucy5xcyA9IHF1ZXJ5c3RyaW5nLnBhcnNlKG9wdGlvbnMucGFyYW1zKTtcbiAgfVxuICBjb25zdCBjbGllbnQgPSBjbGllbnRzW3VybC5wcm90b2NvbF07XG4gIGlmICghY2xpZW50KSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGBVbnN1cHBvcnRlZCBwcm90b2NvbCAke3VybC5wcm90b2NvbH1gKTtcbiAgfVxuICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgIHBvcnQ6IE51bWJlcih1cmwucG9ydCksXG4gICAgcGF0aDogdXJsLnBhdGhuYW1lLFxuICAgIGhvc3RuYW1lOiB1cmwuaG9zdG5hbWUsXG4gICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzLFxuICAgIGVuY29kaW5nOiBudWxsLFxuICAgIGZvbGxvd1JlZGlyZWN0czogb3B0aW9ucy5mb2xsb3dSZWRpcmVjdHMgPT09IHRydWUsXG4gIH07XG4gIGlmIChyZXF1ZXN0T3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgT2JqZWN0LmtleXMocmVxdWVzdE9wdGlvbnMuaGVhZGVycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRlbGV0ZSByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzW2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaWYgKHVybC5zZWFyY2gpIHtcbiAgICBvcHRpb25zLnFzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5xcywgcXVlcnlzdHJpbmcucGFyc2UodXJsLnF1ZXJ5KSk7XG4gIH1cbiAgaWYgKHVybC5hdXRoKSB7XG4gICAgcmVxdWVzdE9wdGlvbnMuYXV0aCA9IHVybC5hdXRoO1xuICB9XG4gIGlmIChvcHRpb25zLnFzKSB7XG4gICAgcmVxdWVzdE9wdGlvbnMucGF0aCArPSBgPyR7cXVlcnlzdHJpbmcuc3RyaW5naWZ5KG9wdGlvbnMucXMpfWA7XG4gIH1cbiAgaWYgKG9wdGlvbnMuYWdlbnQpIHtcbiAgICByZXF1ZXN0T3B0aW9ucy5hZ2VudCA9IG9wdGlvbnMuYWdlbnQ7XG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCByZXEgPSBjbGllbnQucmVxdWVzdChyZXF1ZXN0T3B0aW9ucywgbWFrZUNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCwgb3B0aW9ucykpO1xuICAgIGlmIChvcHRpb25zLmJvZHkpIHtcbiAgICAgIHJlcS53cml0ZShvcHRpb25zLmJvZHkpO1xuICAgIH1cbiAgICByZXEub24oJ2Vycm9yJywgZXJyb3IgPT4ge1xuICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICB9KTtcbiAgICByZXEuZW5kKCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiBQYXJzZS5DbG91ZC5IVFRQT3B0aW9uc1xuICogQHByb3BlcnR5IHtTdHJpbmd8T2JqZWN0fSBib2R5IFRoZSBib2R5IG9mIHRoZSByZXF1ZXN0LiBJZiBpdCBpcyBhIEpTT04gb2JqZWN0LCB0aGVuIHRoZSBDb250ZW50LVR5cGUgc2V0IGluIHRoZSBoZWFkZXJzIG11c3QgYmUgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkIG9yIGFwcGxpY2F0aW9uL2pzb24uIFlvdSBjYW4gYWxzbyBzZXQgdGhpcyB0byBhIHtAbGluayBCdWZmZXJ9IG9iamVjdCB0byBzZW5kIHJhdyBieXRlcy4gSWYgeW91IHVzZSBhIEJ1ZmZlciwgeW91IHNob3VsZCBhbHNvIHNldCB0aGUgQ29udGVudC1UeXBlIGhlYWRlciBleHBsaWNpdGx5IHRvIGRlc2NyaWJlIHdoYXQgdGhlc2UgYnl0ZXMgcmVwcmVzZW50LlxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gZXJyb3IgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHJlcXVlc3QgZmFpbHMuIEl0IHdpbGwgYmUgcGFzc2VkIGEgUGFyc2UuQ2xvdWQuSFRUUFJlc3BvbnNlIG9iamVjdC5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZm9sbG93UmVkaXJlY3RzIFdoZXRoZXIgdG8gZm9sbG93IHJlZGlyZWN0cyBjYXVzZWQgYnkgSFRUUCAzeHggcmVzcG9uc2VzLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdC5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBtZXRob2QgVGhlIG1ldGhvZCBvZiB0aGUgcmVxdWVzdC4gR0VULCBQT1NULCBQVVQsIERFTEVURSwgSEVBRCwgYW5kIE9QVElPTlMgYXJlIHN1cHBvcnRlZC4gV2lsbCBkZWZhdWx0IHRvIEdFVCBpZiBub3Qgc3BlY2lmaWVkLlxuICogQHByb3BlcnR5IHtTdHJpbmd8T2JqZWN0fSBwYXJhbXMgVGhlIHF1ZXJ5IHBvcnRpb24gb2YgdGhlIHVybC4gWW91IGNhbiBwYXNzIGEgSlNPTiBvYmplY3Qgb2Yga2V5IHZhbHVlIHBhaXJzIGxpa2UgcGFyYW1zOiB7cSA6ICdTZWFuIFBsb3R0J30gb3IgYSByYXcgc3RyaW5nIGxpa2UgcGFyYW1zOnE9U2VhbiBQbG90dC5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHN1Y2Nlc3MgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHJlcXVlc3Qgc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlcy4gSXQgd2lsbCBiZSBwYXNzZWQgYSBQYXJzZS5DbG91ZC5IVFRQUmVzcG9uc2Ugb2JqZWN0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVybCBUaGUgdXJsIHRvIHNlbmQgdGhlIHJlcXVlc3QgdG8uXG4gKi9cblxubW9kdWxlLmV4cG9ydHMuZW5jb2RlQm9keSA9IGVuY29kZUJvZHk7XG4iXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUE0QjtBQUU1QixNQUFNQSxPQUFPLEdBQUc7RUFDZCxPQUFPLEVBQUVDLHFCQUFJO0VBQ2IsUUFBUSxFQUFFQztBQUNaLENBQUM7QUFFRCxTQUFTQyxZQUFZLENBQUNDLE9BQU8sRUFBRUMsTUFBTSxFQUFFO0VBQ3JDLE9BQU8sVUFBVUMsUUFBUSxFQUFFO0lBQ3pCLE1BQU1DLE1BQU0sR0FBRyxFQUFFO0lBQ2pCRCxRQUFRLENBQUNFLEVBQUUsQ0FBQyxNQUFNLEVBQUVDLEtBQUssSUFBSTtNQUMzQkYsTUFBTSxDQUFDRyxJQUFJLENBQUNELEtBQUssQ0FBQztJQUNwQixDQUFDLENBQUM7SUFDRkgsUUFBUSxDQUFDRSxFQUFFLENBQUMsS0FBSyxFQUFFLE1BQU07TUFDdkIsTUFBTUcsSUFBSSxHQUFHQyxNQUFNLENBQUNDLE1BQU0sQ0FBQ04sTUFBTSxDQUFDO01BQ2xDLE1BQU1PLFlBQVksR0FBRyxJQUFJQyxxQkFBWSxDQUFDVCxRQUFRLEVBQUVLLElBQUksQ0FBQzs7TUFFckQ7TUFDQSxJQUFJRyxZQUFZLENBQUNFLE1BQU0sR0FBRyxHQUFHLElBQUlGLFlBQVksQ0FBQ0UsTUFBTSxJQUFJLEdBQUcsRUFBRTtRQUMzRCxPQUFPWCxNQUFNLENBQUNTLFlBQVksQ0FBQztNQUM3QixDQUFDLE1BQU07UUFDTCxPQUFPVixPQUFPLENBQUNVLFlBQVksQ0FBQztNQUM5QjtJQUNGLENBQUMsQ0FBQztJQUNGUixRQUFRLENBQUNFLEVBQUUsQ0FBQyxPQUFPLEVBQUVILE1BQU0sQ0FBQztFQUM5QixDQUFDO0FBQ0g7QUFFQSxNQUFNWSxVQUFVLEdBQUcsVUFBVTtFQUFFTixJQUFJO0VBQUVPLE9BQU8sR0FBRyxDQUFDO0FBQUUsQ0FBQyxFQUFFO0VBQ25ELElBQUksT0FBT1AsSUFBSSxLQUFLLFFBQVEsRUFBRTtJQUM1QixPQUFPO01BQUVBLElBQUk7TUFBRU87SUFBUSxDQUFDO0VBQzFCO0VBQ0EsSUFBSUMsZUFBZSxHQUFHQyxNQUFNLENBQUNDLElBQUksQ0FBQ0gsT0FBTyxDQUFDLENBQUNJLE1BQU0sQ0FBQ0MsR0FBRyxJQUFJO0lBQ3ZELE9BQU9BLEdBQUcsQ0FBQ0MsS0FBSyxDQUFDLGVBQWUsQ0FBQyxJQUFJLElBQUk7RUFDM0MsQ0FBQyxDQUFDO0VBRUYsSUFBSUwsZUFBZSxDQUFDTSxNQUFNLElBQUksQ0FBQyxFQUFFO0lBQy9CO0lBQ0E7O0lBRUFkLElBQUksR0FBR2Usb0JBQVcsQ0FBQ0MsU0FBUyxDQUFDaEIsSUFBSSxDQUFDO0lBQ2xDTyxPQUFPLENBQUMsY0FBYyxDQUFDLEdBQUcsbUNBQW1DO0VBQy9ELENBQUMsTUFBTTtJQUNMO0lBQ0EsSUFBSUMsZUFBZSxDQUFDTSxNQUFNLEdBQUcsQ0FBQyxFQUFFO01BQzlCRyxlQUFHLENBQUNDLEtBQUssQ0FBQyx5QkFBeUIsRUFBRSx3Q0FBd0MsQ0FBQztJQUNoRjtJQUNBO0lBQ0EsSUFBSUMsV0FBVyxHQUFHWCxlQUFlLENBQUMsQ0FBQyxDQUFDO0lBQ3BDLElBQUlELE9BQU8sQ0FBQ1ksV0FBVyxDQUFDLENBQUNOLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFO01BQ3BEYixJQUFJLEdBQUdvQixJQUFJLENBQUNKLFNBQVMsQ0FBQ2hCLElBQUksQ0FBQztJQUM3QixDQUFDLE1BQU0sSUFBSU8sT0FBTyxDQUFDWSxXQUFXLENBQUMsQ0FBQ04sS0FBSyxDQUFDLHFDQUFxQyxDQUFDLEVBQUU7TUFDNUViLElBQUksR0FBR2Usb0JBQVcsQ0FBQ0MsU0FBUyxDQUFDaEIsSUFBSSxDQUFDO0lBQ3BDO0VBQ0Y7RUFDQSxPQUFPO0lBQUVBLElBQUk7SUFBRU87RUFBUSxDQUFDO0FBQzFCLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQWMsTUFBTSxDQUFDQyxPQUFPLEdBQUcsU0FBU0MsV0FBVyxDQUFDQyxPQUFPLEVBQUU7RUFDN0MsSUFBSUMsR0FBRztFQUNQLElBQUk7SUFDRkEsR0FBRyxHQUFHLElBQUFDLFVBQUssRUFBQ0YsT0FBTyxDQUFDQyxHQUFHLENBQUM7RUFDMUIsQ0FBQyxDQUFDLE9BQU9FLENBQUMsRUFBRTtJQUNWLE9BQU9DLE9BQU8sQ0FBQ2xDLE1BQU0sQ0FBQ2lDLENBQUMsQ0FBQztFQUMxQjtFQUNBSCxPQUFPLEdBQUdmLE1BQU0sQ0FBQ29CLE1BQU0sQ0FBQ0wsT0FBTyxFQUFFbEIsVUFBVSxDQUFDa0IsT0FBTyxDQUFDLENBQUM7RUFDckQ7RUFDQSxJQUFJLE9BQU9BLE9BQU8sQ0FBQ00sTUFBTSxLQUFLLFFBQVEsRUFBRTtJQUN0Q04sT0FBTyxDQUFDTyxFQUFFLEdBQUdQLE9BQU8sQ0FBQ00sTUFBTTtFQUM3QixDQUFDLE1BQU0sSUFBSSxPQUFPTixPQUFPLENBQUNNLE1BQU0sS0FBSyxRQUFRLEVBQUU7SUFDN0NOLE9BQU8sQ0FBQ08sRUFBRSxHQUFHaEIsb0JBQVcsQ0FBQ1csS0FBSyxDQUFDRixPQUFPLENBQUNNLE1BQU0sQ0FBQztFQUNoRDtFQUNBLE1BQU1FLE1BQU0sR0FBRzNDLE9BQU8sQ0FBQ29DLEdBQUcsQ0FBQ1EsUUFBUSxDQUFDO0VBQ3BDLElBQUksQ0FBQ0QsTUFBTSxFQUFFO0lBQ1gsT0FBT0osT0FBTyxDQUFDbEMsTUFBTSxDQUFFLHdCQUF1QitCLEdBQUcsQ0FBQ1EsUUFBUyxFQUFDLENBQUM7RUFDL0Q7RUFDQSxNQUFNQyxjQUFjLEdBQUc7SUFDckJDLE1BQU0sRUFBRVgsT0FBTyxDQUFDVyxNQUFNO0lBQ3RCQyxJQUFJLEVBQUVDLE1BQU0sQ0FBQ1osR0FBRyxDQUFDVyxJQUFJLENBQUM7SUFDdEJFLElBQUksRUFBRWIsR0FBRyxDQUFDYyxRQUFRO0lBQ2xCQyxRQUFRLEVBQUVmLEdBQUcsQ0FBQ2UsUUFBUTtJQUN0QmpDLE9BQU8sRUFBRWlCLE9BQU8sQ0FBQ2pCLE9BQU87SUFDeEJrQyxRQUFRLEVBQUUsSUFBSTtJQUNkQyxlQUFlLEVBQUVsQixPQUFPLENBQUNrQixlQUFlLEtBQUs7RUFDL0MsQ0FBQztFQUNELElBQUlSLGNBQWMsQ0FBQzNCLE9BQU8sRUFBRTtJQUMxQkUsTUFBTSxDQUFDQyxJQUFJLENBQUN3QixjQUFjLENBQUMzQixPQUFPLENBQUMsQ0FBQ29DLE9BQU8sQ0FBQy9CLEdBQUcsSUFBSTtNQUNqRCxJQUFJLE9BQU9zQixjQUFjLENBQUMzQixPQUFPLENBQUNLLEdBQUcsQ0FBQyxLQUFLLFdBQVcsRUFBRTtRQUN0RCxPQUFPc0IsY0FBYyxDQUFDM0IsT0FBTyxDQUFDSyxHQUFHLENBQUM7TUFDcEM7SUFDRixDQUFDLENBQUM7RUFDSjtFQUNBLElBQUlhLEdBQUcsQ0FBQ21CLE1BQU0sRUFBRTtJQUNkcEIsT0FBTyxDQUFDTyxFQUFFLEdBQUd0QixNQUFNLENBQUNvQixNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUVMLE9BQU8sQ0FBQ08sRUFBRSxFQUFFaEIsb0JBQVcsQ0FBQ1csS0FBSyxDQUFDRCxHQUFHLENBQUNvQixLQUFLLENBQUMsQ0FBQztFQUMxRTtFQUNBLElBQUlwQixHQUFHLENBQUNxQixJQUFJLEVBQUU7SUFDWlosY0FBYyxDQUFDWSxJQUFJLEdBQUdyQixHQUFHLENBQUNxQixJQUFJO0VBQ2hDO0VBQ0EsSUFBSXRCLE9BQU8sQ0FBQ08sRUFBRSxFQUFFO0lBQ2RHLGNBQWMsQ0FBQ0ksSUFBSSxJQUFLLElBQUd2QixvQkFBVyxDQUFDQyxTQUFTLENBQUNRLE9BQU8sQ0FBQ08sRUFBRSxDQUFFLEVBQUM7RUFDaEU7RUFDQSxJQUFJUCxPQUFPLENBQUN1QixLQUFLLEVBQUU7SUFDakJiLGNBQWMsQ0FBQ2EsS0FBSyxHQUFHdkIsT0FBTyxDQUFDdUIsS0FBSztFQUN0QztFQUNBLE9BQU8sSUFBSW5CLE9BQU8sQ0FBQyxDQUFDbkMsT0FBTyxFQUFFQyxNQUFNLEtBQUs7SUFDdEMsTUFBTXNELEdBQUcsR0FBR2hCLE1BQU0sQ0FBQ2lCLE9BQU8sQ0FBQ2YsY0FBYyxFQUFFMUMsWUFBWSxDQUFDQyxPQUFPLEVBQUVDLE1BQU0sRUFBRThCLE9BQU8sQ0FBQyxDQUFDO0lBQ2xGLElBQUlBLE9BQU8sQ0FBQ3hCLElBQUksRUFBRTtNQUNoQmdELEdBQUcsQ0FBQ0UsS0FBSyxDQUFDMUIsT0FBTyxDQUFDeEIsSUFBSSxDQUFDO0lBQ3pCO0lBQ0FnRCxHQUFHLENBQUNuRCxFQUFFLENBQUMsT0FBTyxFQUFFcUIsS0FBSyxJQUFJO01BQ3ZCeEIsTUFBTSxDQUFDd0IsS0FBSyxDQUFDO0lBQ2YsQ0FBQyxDQUFDO0lBQ0Y4QixHQUFHLENBQUNHLEdBQUcsRUFBRTtFQUNYLENBQUMsQ0FBQztBQUNKLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTlCLE1BQU0sQ0FBQ0MsT0FBTyxDQUFDaEIsVUFBVSxHQUFHQSxVQUFVIn0=