"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.md5Hash = md5Hash;
exports.newObjectId = newObjectId;
exports.newToken = newToken;
exports.randomHexString = randomHexString;
exports.randomString = randomString;
var _crypto = require("crypto");
// Returns a new random hex string of the given even size.
function randomHexString(size) {
  if (size === 0) {
    throw new Error('Zero-length randomHexString is useless.');
  }
  if (size % 2 !== 0) {
    throw new Error('randomHexString size must be divisible by 2.');
  }
  return (0, _crypto.randomBytes)(size / 2).toString('hex');
}

// Returns a new random alphanumeric string of the given size.
//
// Note: to simplify implementation, the result has slight modulo bias,
// because chars length of 62 doesn't divide the number of all bytes
// (256) evenly. Such bias is acceptable for most cases when the output
// length is long enough and doesn't need to be uniform.
function randomString(size) {
  if (size === 0) {
    throw new Error('Zero-length randomString is useless.');
  }
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789';
  let objectId = '';
  const bytes = (0, _crypto.randomBytes)(size);
  for (let i = 0; i < bytes.length; ++i) {
    objectId += chars[bytes.readUInt8(i) % chars.length];
  }
  return objectId;
}

// Returns a new random alphanumeric string suitable for object ID.
function newObjectId(size = 10) {
  return randomString(size);
}

// Returns a new random hex string suitable for secure tokens.
function newToken() {
  return randomHexString(32);
}
function md5Hash(string) {
  return (0, _crypto.createHash)('md5').update(string).digest('hex');
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJyYW5kb21IZXhTdHJpbmciLCJzaXplIiwiRXJyb3IiLCJyYW5kb21CeXRlcyIsInRvU3RyaW5nIiwicmFuZG9tU3RyaW5nIiwiY2hhcnMiLCJvYmplY3RJZCIsImJ5dGVzIiwiaSIsImxlbmd0aCIsInJlYWRVSW50OCIsIm5ld09iamVjdElkIiwibmV3VG9rZW4iLCJtZDVIYXNoIiwic3RyaW5nIiwiY3JlYXRlSGFzaCIsInVwZGF0ZSIsImRpZ2VzdCJdLCJzb3VyY2VzIjpbIi4uL3NyYy9jcnlwdG9VdGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBAZmxvdyAqL1xuXG5pbXBvcnQgeyByYW5kb21CeXRlcywgY3JlYXRlSGFzaCB9IGZyb20gJ2NyeXB0byc7XG5cbi8vIFJldHVybnMgYSBuZXcgcmFuZG9tIGhleCBzdHJpbmcgb2YgdGhlIGdpdmVuIGV2ZW4gc2l6ZS5cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21IZXhTdHJpbmcoc2l6ZTogbnVtYmVyKTogc3RyaW5nIHtcbiAgaWYgKHNpemUgPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1plcm8tbGVuZ3RoIHJhbmRvbUhleFN0cmluZyBpcyB1c2VsZXNzLicpO1xuICB9XG4gIGlmIChzaXplICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncmFuZG9tSGV4U3RyaW5nIHNpemUgbXVzdCBiZSBkaXZpc2libGUgYnkgMi4nKTtcbiAgfVxuICByZXR1cm4gcmFuZG9tQnl0ZXMoc2l6ZSAvIDIpLnRvU3RyaW5nKCdoZXgnKTtcbn1cblxuLy8gUmV0dXJucyBhIG5ldyByYW5kb20gYWxwaGFudW1lcmljIHN0cmluZyBvZiB0aGUgZ2l2ZW4gc2l6ZS5cbi8vXG4vLyBOb3RlOiB0byBzaW1wbGlmeSBpbXBsZW1lbnRhdGlvbiwgdGhlIHJlc3VsdCBoYXMgc2xpZ2h0IG1vZHVsbyBiaWFzLFxuLy8gYmVjYXVzZSBjaGFycyBsZW5ndGggb2YgNjIgZG9lc24ndCBkaXZpZGUgdGhlIG51bWJlciBvZiBhbGwgYnl0ZXNcbi8vICgyNTYpIGV2ZW5seS4gU3VjaCBiaWFzIGlzIGFjY2VwdGFibGUgZm9yIG1vc3QgY2FzZXMgd2hlbiB0aGUgb3V0cHV0XG4vLyBsZW5ndGggaXMgbG9uZyBlbm91Z2ggYW5kIGRvZXNuJ3QgbmVlZCB0byBiZSB1bmlmb3JtLlxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbVN0cmluZyhzaXplOiBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignWmVyby1sZW5ndGggcmFuZG9tU3RyaW5nIGlzIHVzZWxlc3MuJyk7XG4gIH1cbiAgY29uc3QgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonICsgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyArICcwMTIzNDU2Nzg5JztcbiAgbGV0IG9iamVjdElkID0gJyc7XG4gIGNvbnN0IGJ5dGVzID0gcmFuZG9tQnl0ZXMoc2l6ZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICBvYmplY3RJZCArPSBjaGFyc1tieXRlcy5yZWFkVUludDgoaSkgJSBjaGFycy5sZW5ndGhdO1xuICB9XG4gIHJldHVybiBvYmplY3RJZDtcbn1cblxuLy8gUmV0dXJucyBhIG5ldyByYW5kb20gYWxwaGFudW1lcmljIHN0cmluZyBzdWl0YWJsZSBmb3Igb2JqZWN0IElELlxuZXhwb3J0IGZ1bmN0aW9uIG5ld09iamVjdElkKHNpemU6IG51bWJlciA9IDEwKTogc3RyaW5nIHtcbiAgcmV0dXJuIHJhbmRvbVN0cmluZyhzaXplKTtcbn1cblxuLy8gUmV0dXJucyBhIG5ldyByYW5kb20gaGV4IHN0cmluZyBzdWl0YWJsZSBmb3Igc2VjdXJlIHRva2Vucy5cbmV4cG9ydCBmdW5jdGlvbiBuZXdUb2tlbigpOiBzdHJpbmcge1xuICByZXR1cm4gcmFuZG9tSGV4U3RyaW5nKDMyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1kNUhhc2goc3RyaW5nOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gY3JlYXRlSGFzaCgnbWQ1JykudXBkYXRlKHN0cmluZykuZGlnZXN0KCdoZXgnKTtcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUVBO0FBRUE7QUFDTyxTQUFTQSxlQUFlLENBQUNDLElBQVksRUFBVTtFQUNwRCxJQUFJQSxJQUFJLEtBQUssQ0FBQyxFQUFFO0lBQ2QsTUFBTSxJQUFJQyxLQUFLLENBQUMseUNBQXlDLENBQUM7RUFDNUQ7RUFDQSxJQUFJRCxJQUFJLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRTtJQUNsQixNQUFNLElBQUlDLEtBQUssQ0FBQyw4Q0FBOEMsQ0FBQztFQUNqRTtFQUNBLE9BQU8sSUFBQUMsbUJBQVcsRUFBQ0YsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDRyxRQUFRLENBQUMsS0FBSyxDQUFDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNDLFlBQVksQ0FBQ0osSUFBWSxFQUFVO0VBQ2pELElBQUlBLElBQUksS0FBSyxDQUFDLEVBQUU7SUFDZCxNQUFNLElBQUlDLEtBQUssQ0FBQyxzQ0FBc0MsQ0FBQztFQUN6RDtFQUNBLE1BQU1JLEtBQUssR0FBRyw0QkFBNEIsR0FBRyw0QkFBNEIsR0FBRyxZQUFZO0VBQ3hGLElBQUlDLFFBQVEsR0FBRyxFQUFFO0VBQ2pCLE1BQU1DLEtBQUssR0FBRyxJQUFBTCxtQkFBVyxFQUFDRixJQUFJLENBQUM7RUFDL0IsS0FBSyxJQUFJUSxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUdELEtBQUssQ0FBQ0UsTUFBTSxFQUFFLEVBQUVELENBQUMsRUFBRTtJQUNyQ0YsUUFBUSxJQUFJRCxLQUFLLENBQUNFLEtBQUssQ0FBQ0csU0FBUyxDQUFDRixDQUFDLENBQUMsR0FBR0gsS0FBSyxDQUFDSSxNQUFNLENBQUM7RUFDdEQ7RUFDQSxPQUFPSCxRQUFRO0FBQ2pCOztBQUVBO0FBQ08sU0FBU0ssV0FBVyxDQUFDWCxJQUFZLEdBQUcsRUFBRSxFQUFVO0VBQ3JELE9BQU9JLFlBQVksQ0FBQ0osSUFBSSxDQUFDO0FBQzNCOztBQUVBO0FBQ08sU0FBU1ksUUFBUSxHQUFXO0VBQ2pDLE9BQU9iLGVBQWUsQ0FBQyxFQUFFLENBQUM7QUFDNUI7QUFFTyxTQUFTYyxPQUFPLENBQUNDLE1BQWMsRUFBVTtFQUM5QyxPQUFPLElBQUFDLGtCQUFVLEVBQUMsS0FBSyxDQUFDLENBQUNDLE1BQU0sQ0FBQ0YsTUFBTSxDQUFDLENBQUNHLE1BQU0sQ0FBQyxLQUFLLENBQUM7QUFDdkQifQ==